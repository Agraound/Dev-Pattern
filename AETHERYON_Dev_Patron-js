# AETHERYON Dev Pattern — JavaScript/Node.js

---

## ¿En qué nivel estoy? (Guía rápida)

Si tu proyecto…

- **Es un script que tú solo usarás** → Nivel 1
- **Tiene UI/CLI separada pero dominio simple** → Nivel 2
- **Tiene reglas de negocio claras y crecerá** → Nivel 3
- **Está en producción y requiere calidad y equipo** → Nivel 4
- **Tiene UI compleja con mucho estado** → Nivel 5

---

## Marco Estratégico

### ¿Qué problema resuelve AETHERYON?

Todo proyecto empieza simple.

Si crece sin estructura, colapsa.

AETHERYON resuelve el problema de **cómo evolucionar desde un script hasta un sistema profesional sin reescribirlo cada vez**.

No es una arquitectura fija.  
Es un **camino evolutivo con niveles claros**.

### ¿Qué significa escalar?

Escalar no es hacer más grande.

Es **agregar estructura cuando el costo del desorden supera el costo de la estructura**.

Cada transición agrega:

- Separación de responsabilidades
- Testeabilidad
- Coordinación en equipo
- Seguridad evolutiva

Pero también complejidad.

---

### Frase ancla

> **"Construye para hoy. Prepara para mañana. Nunca pagues por adelantado lo que puedas diferir con conciencia."**

---

## Línea Evolutiva Visual

```
Nivel 1         →    Nivel 2         →    Nivel 3         →    Nivel 4           →    Nivel 5
Script único    →    Separación      →    Capas limpias   →    Producto           →    UI estructurada
(prototipo)          básica                (Domain/App)         profesional            (MVVM)
     │                   │                      │                    │                      │
     ▼                   ▼                      ▼                    ▼                      ▼
 200 líneas        Lógica/UI           Domain puro          80% cobertura        ViewModels
                  separados            sin I/O               tests                testeables
```

### Transiciones Arquitectónicas

- **T1 — Separación por claridad** (Nivel 1 → Nivel 2)
- **T2 — Separación por dominio** (Nivel 2 → Nivel 3)
- **T3 — Separación por calidad** (Nivel 3 → Nivel 4)
- **T4 — Separación por experiencia de usuario** (Nivel 4 → Nivel 5)

---

## Tabla Comparativa de Niveles

| Nivel | Nombre            | Equipo   | Complejidad | Testing  | MVVM | Cuándo usarlo                                           |
|-------|-------------------|----------|-------------|----------|------|---------------------------------------------------------|
| 1     | Standalone Script | 1 dev    | Mínima      | No       | No   | Prototipo, validación rápida, scripts de automatización |
| 2     | BF                | 1-2 devs | Baja        | No       | No   | Proyecto pequeño con lógica separada de presentación    |
| 3     | AUDI              | 2-4 devs | Media       | Opcional | No   | Proyecto con dominio definido y crecimiento esperado    |
| 4     | AUDDITS           | 3-6 devs | Alta        | Sí       | No   | Producto en producción con múltiples módulos            |
| 5     | AUDDITS + MVVM    | 4+ devs  | Muy alta    | Sí       | Sí   | Sistema complejo con UI rica y múltiples vistas         |

---

## Nivel 1 — Standalone Script

Si estás empezando algo hoy, probablemente estés aquí.

Un solo archivo. Sin carpetas. Sin arquitectura.

**Es válido.**

### ⚠ Señal de transición (T1 — Separación por claridad)

Si tu script supera las 200 líneas, si empiezas a copiar y pegar bloques, o si otro desarrollador necesita trabajar en paralelo, es momento de escalar a Nivel 2.

### Principios del Nivel 1

- Todo en un solo archivo es aceptable mientras el alcance sea claro.
- Preferir funciones puras. Evitar estado global innecesario.
- Documentar la intención del script al inicio del archivo.

### Antipatrón fundamental

```javascript
// ❌ MAL — lógica mezclada con presentación
function calcularDescuento(precio, porcentaje) {
    const resultado = precio - (precio * porcentaje / 100);
    console.log(`Descuento aplicado: ${resultado}`); // MEZCLA
    return resultado;
}

// ✅ BIEN — responsabilidades separadas (mismo archivo)
function calcularDescuento(precio, porcentaje) {
    return precio - (precio * porcentaje / 100);
}

function mostrarResultado(resultado) {
    console.log(`Descuento aplicado: ${resultado}`);
}
```

### Ejemplo 1: Versión ultra mínima

```javascript
#!/usr/bin/env node
// calculadora.js — lo mínimo que funciona

function sumar(a, b) { return a + b; }
function restar(a, b) { return a - b; }

const args = process.argv.slice(2);
const op = args[0];
const a = parseFloat(args[1]);
const b = parseFloat(args[2]);

if (op === 'sumar') console.log(sumar(a, b));
if (op === 'restar') console.log(restar(a, b));
```

Este script es válido. Hace su trabajo.

Pero cuando necesites más comandos, validaciones o modos…

### Ejemplo 2: Versión evolucionada (multi-modo)

```javascript
#!/usr/bin/env node
/**
 * calculadora-evolucionada.js — misma esencia, más capacidades
 */

const { program } = require('commander');

// ===== DOMAIN ===== (lógica pura)
function sumar(a, b) { return a + b; }
function restar(a, b) { return a - b; }
function multiplicar(a, b) { return a * b; }
function dividir(a, b) {
    if (b === 0) throw new Error('No se puede dividir por cero');
    return a / b;
}

// ===== CLI ===== (interacción)
program
    .version('1.0.0')
    .description('Calculadora con múltiples modos');

program
    .command('operar <tipo> <a> <b>')
    .action((tipo, a, b) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        
        try {
            let resultado;
            switch(tipo) {
                case 'sumar': resultado = sumar(numA, numB); break;
                case 'restar': resultado = restar(numA, numB); break;
                case 'multiplicar': resultado = multiplicar(numA, numB); break;
                case 'dividir': resultado = dividir(numA, numB); break;
                default: throw new Error('Operación no válida');
            }
            console.log(`✅ Resultado: ${resultado}`);
        } catch (error) {
            console.log(`❌ Error: ${error.message}`);
        }
    });

program.parse(process.argv);
```

**La progresión es clara:** la lógica de negocio (sumar, restar) sigue siendo la misma. Solo se ha envuelto en más capacidades de interacción.

---

## Nivel 2 — Patrón BF (Backend–Frontend)

### El primer acto de disciplina

Aquí ocurre un cambio mental fundamental: **separar responsabilidades no por conveniencia, sino por contrato.**

El Backend expone una API pública. El Frontend la consume sin conocer su implementación.

### Frase clave

> **"Aquí comienza el pensamiento en contratos. Aquí empieza la disciplina de desacoplamiento."**

### Estructura

```
backend.js  ←  Contrato explícito (API pública)
     ↑
     │ (solo consume)
     ↓
cli.js      ←  Interacción con usuario
```

### ⚠ Señal de transición (T2 — Separación por dominio)

Si aparecen múltiples entidades de negocio con reglas propias, si Infrastructure comienza a crecer (base de datos, APIs externas), o si el equipo crece y dos archivos ya no alcanzan para dividir el trabajo, escala a Nivel 3.

### Principios del Nivel 2

- `backend.js` contiene toda la lógica de negocio y acceso a datos.
- `frontend.js` (o `cli.js`) solo consume métodos públicos del backend.
- El frontend nunca importa librerías de acceso a datos directamente.
- El backend no escribe en consola ni interactúa con el usuario.

### Contrato explícito

```javascript
// backend.js
class Backend {
    async obtenerUsuarios() {} // ← Contrato público
    async crearUsuario(datos) {} // ← Contrato público
}

module.exports = Backend;
```

### Antipatrón a evitar

```javascript
// ❌ MAL — el frontend accede directamente a la base de datos
const sqlite3 = require('sqlite3');
const db = new sqlite3.Database('db.sqlite');
db.all('SELECT * FROM usuarios', (err, rows) => {
    // lógica aquí
});

// ✅ BIEN — el frontend delega al backend
const Backend = require('./backend');
const backend = new Backend();
const usuarios = await backend.obtenerUsuarios();
```

---

## Nivel 3 — Patrón AUDI

### La arquitectura por capas

Aquí ocurre la segunda gran disciplina: **separar el dominio del mundo exterior.**

Domain es el corazón del negocio. No sabe de bases de datos, ni de APIs, ni de interfaces de usuario. Es puro, testeable, expresivo.

### Regla nuclear (destacada)

> **Si el Domain necesita importar algo externo, la arquitectura está rota.**

### Jerarquía visual

```
    ┌─────────────────┐
    │    Domain       │  ← Puro. Sin imports externos.
    │  (entidades)    │    Solo lógica de negocio.
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐
    │  Application    │  ← Orquesta casos de uso.
    │  (servicios)    │    Depende solo de Domain.
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐
    │ Infrastructure  │  ← Implementa contratos.
    │   (DB, APIs)    │    Depende de Application y Domain.
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐
    │ User Interface  │  ← Consume Application.
    │   (CLI, GUI)    │    Nunca Infrastructure directo.
    └─────────────────┘
```

### Puerto explícito (Contrato)

```javascript
// Application/ports/RepositorioUsuario.js
export class RepositorioUsuario {
    async obtenerPorId(id) {
        throw new Error('No implementado'); // ← Contrato
    }
}
```

Infrastructure implementa el contrato.  
Application depende del contrato, no de la implementación concreta.  
Domain no depende de nadie.

### ⚠ Señal de transición (T3 — Separación por calidad)

Si el equipo necesita pruebas automatizadas, si hay scripts de migración o seed data recurrentes, o si la documentación interna se vuelve necesaria para onboarding, escala a Nivel 4.

### Asincronía en AUDI

```javascript
// Infrastructure — async para I/O
export class RepositorioUsuarioSQL {
    async obtenerPorId(id) {
        const db = await this._getConnection();
        return db.get('SELECT * FROM usuarios WHERE id = ?', id);
    }
}

// Application — propaga async según necesidad
export class ServicioUsuario {
    async obtenerUsuario(id) {
        const usuario = await this.repositorio.obtenerPorId(id);
        return UsuarioDTO.desdeEntidad(usuario);
    }
}

// Domain — siempre sync (lógica pura, sin I/O)
export class Usuario {
    aplicarDescuento(porcentaje) {
        if (porcentaje < 0 || porcentaje > 100) {
            throw new Error(`Descuento inválido: ${porcentaje}`);
        }
        return this.precio * (1 - porcentaje / 100);
    }
}
```

---

## Nivel 4 — Patrón AUDDITS

### El producto profesional

Nivel 3 te dio orden. Nivel 4 te da **calidad, repetibilidad y sostenibilidad**.

Aquí agregamos pruebas, scripts, documentación y flujos de equipo. El código ya no es solo funcional: es **profesional**.

### ⚠ Advertencia estratégica

**Nivel 4 no es obligatorio.**

Si el producto no lo exige, permanecer en Nivel 3 es una decisión profesional válida.

No escalas porque "es mejor". Escalas porque **el costo de no hacerlo supera el costo de hacerlo**.

### Estructura típica

```
src/
 ├─ Domain/
 ├─ Application/
 ├─ Infrastructure/
 ├─ UI/

tests/
scripts/
docs/
```

### Reglas Arquitectónicas

**Regla #1 — Responsabilidad Única**

Cada archivo, clase y función tiene una sola razón para cambiar.

```javascript
// ❌ MAL — tres responsabilidades
class ServicioUsuario {
    async registrar(datos) {
        if (!datos.email) throw new Error();   // validación
        await this.db.guardar(datos);          // persistencia
        await this.email.enviarBienvenida();   // notificación
    }
}

// ✅ BIEN — cada responsabilidad en su lugar
class ServicioRegistro {
    constructor(validador, repositorio, eventEmitter) {
        this.validador = validador;
        this.repositorio = repositorio;
        this.eventEmitter = eventEmitter;
    }

    async registrar(dto) {
        const usuario = this.validador.validar(dto);
        await this.repositorio.guardar(usuario);
        this.eventEmitter.emit('usuario.registrado', usuario.id);
        return usuario;
    }
}
```

**Regla #2 — Dependencias Direccionales**

- Domain → No depende de nadie.
- Application → Solo depende de Domain.
- Infrastructure → Depende de Application y Domain.
- UI → Depende de Application. Nunca de Infrastructure directo.

**Regla #3 — Inyección de Dependencias**

```javascript
// ✅ BIEN — inyectada, testeable
export class ServicioUsuario {
    constructor(repositorio) {
        this.repositorio = repositorio;
    }
}

// ❌ MAL — oculta, imposible de mockear
export class ServicioUsuario {
    constructor() {
        this.repositorio = new RepositorioUsuarioSQL();
    }
}
```

**Regla #4 — DTOs vs Entidades**

- Entidades: contienen lógica de negocio.
- DTOs: solo transportan datos entre capas.

### Reglas de Calidad

**Regla #5 — Pruebas obligatorias**

- Cada módulo tiene su test.
- Pruebas independientes y repetibles.
- Mocks para servicios externos.
- Cobertura ≥ 80%.

```javascript
// Tests/test_domain/usuario.test.js
import { Usuario } from '../../Domain/entidades/usuario.js';

describe('Usuario', () => {
    test('email inválido lanza error', () => {
        const usuario = new Usuario(1, 'Juan', 'juan@example.com');
        expect(() => {
            usuario.cambiarEmail('email-invalido');
        }).toThrow('Email inválido');
    });
});
```

**Regla #6 — Documentación con JSDoc**

```javascript
/**
 * Procesa un pago.
 * @param {Object} params - Parámetros del pago
 * @param {number} params.usuarioId - ID del usuario
 * @returns {Promise<Object>} Resultado
 */
async function procesarPago({ usuarioId, monto }) {
    // implementación
}
```

**Regla #7 — Manejo de Errores**

- Negocio → Domain/excepciones/
- Técnicos → Infrastructure/
- UI → Mensajes amigables

### Reglas de Equipo

**Regla #8 — Nomenclatura Consistente**

- Clases → PascalCase
- Métodos → camelCase
- Constantes → UPPER_SNAKE_CASE
- Archivos → kebab-case.js

**Regla #9 — Git Workflow**

```
main      → Producción
develop   → Integración
feature/* → Nuevas funcionalidades
hotfix/*  → Correcciones urgentes
```

```bash
feat(usuarios): buscar por email
fix(pagos): corregir impuestos
docs(api): actualizar endpoints
test(usuarios): pruebas de registro
```

**Regla #10 — bootstrap.js como Orquestador**

```javascript
export class Application {
    constructor() {
        this.backend = null;
    }

    inicializar(modo = 'desarrollo') {
        const config = {
            desarrollo: { dbPath: 'data/dev.db' },
            produccion: { dbPath: process.env.DB_PATH }
        }[modo];

        this.backend = new Backend(config);
    }

    async ejecutar() {
        const cli = new CLI(this.backend);
        await cli.iniciar();
    }
}
```

---

## Nivel 5 — AUDDITS + MVVM

### Sistemas con UI compleja

Cuando la interfaz de usuario crece, el desorden migra a la UI.

MVVM rescata ese caos separando:

- **View** → Solo renderizado y binding
- **ViewModel** → Estado observable y lógica de UI
- **Model** → Datos (UI o negocio)

### ⚠ Señal de transición (T4 — Separación por experiencia de usuario)

Si la UI se vuelve compleja con múltiples vistas y estado compartido, si necesitas testear la lógica de presentación sin levantar la interfaz, o si prevés reutilizar la lógica de UI en múltiples frameworks, escala a Nivel 5.

### ⚠ Advertencia estratégica

**MVVM no es para todos los proyectos.**

Evítalo si:
- La UI tiene una sola vista sin estado complejo.
- El proyecto es interno o de vida corta.
- El equipo no tiene experiencia con el patrón.
- El estado de UI es mínimo y local.

Si puedes resolverlo con estado local simple, **no lo uses**.

---

### ViewModelBase

```javascript
import EventEmitter from 'events';

export class ViewModelBase extends EventEmitter {
    constructor() {
        super();
        this._propiedades = new Map();
        this._ocupado = false;
    }

    notificarCambio(nombre, valor) {
        this.emit('cambio', { nombre, valor });
    }

    set ocupado(valor) {
        this._ocupado = valor;
        this.notificarCambio('ocupado', valor);
    }

    get ocupado() {
        return this._ocupado;
    }
}
```

### ViewModel concreto

```javascript
import { ViewModelBase } from './viewmodelBase.js';
import { UIUsuario } from '../models/uiUsuario.js';

export class UsuarioViewModel extends ViewModelBase {
    constructor(backend) {
        super();
        this.backend = backend;
        this._usuarios = [];
        this._filtroNombre = '';
        this.cargarUsuarios();
    }

    get usuarios() {
        if (!this._filtroNombre) return this._usuarios;
        const filtro = this._filtroNombre.toLowerCase();
        return this._usuarios.filter(u => 
            u.nombre.toLowerCase().includes(filtro)
        );
    }

    set filtroNombre(valor) {
        this._filtroNombre = valor;
        this.notificarCambio('usuarios', this.usuarios);
    }

    async cargarUsuarios() {
        this.ocupado = true;
        
        try {
            const dtos = await this.backend.obtenerUsuarios();
            this._usuarios = dtos.map(dto => UIUsuario.fromDTO(dto));
            this.notificarCambio('usuarios', this.usuarios);
        } catch (error) {
            this.notificarCambio('error', error.message);
        } finally {
            this.ocupado = false;
        }
    }
}
```

### Binding con React

```jsx
import React, { useState, useEffect } from 'react';

export function VistaUsuarios({ viewmodel }) {
    const [usuarios, setUsuarios] = useState([]);
    const [ocupado, setOcupado] = useState(false);

    useEffect(() => {
        const handleCambio = (evento) => {
            if (evento.nombre === 'usuarios') {
                setUsuarios(evento.valor);
            } else if (evento.nombre === 'ocupado') {
                setOcupado(evento.valor);
            }
        };

        viewmodel.on('cambio', handleCambio);
        viewmodel.cargarUsuarios();
        
        return () => viewmodel.off('cambio', handleCambio);
    }, [viewmodel]);

    return (
        <div>
            {ocupado && <div>Cargando...</div>}
            <ul>
                {usuarios.map(u => (
                    <li key={u.id}>{u.nombre} - {u.email}</li>
                ))}
            </ul>
        </div>
    );
}
```

---

## Cierre Filosófico

### La sabiduría de no complicar

AETHERYON no es una invitación a la complejidad.

Es una herramienta para **saber cuándo detenerse**.

- Si tu script tiene 50 líneas y nunca crecerá → Nivel 1.
- Si tu equipo es de dos personas y el dominio es simple → Nivel 2.
- Si tu producto está en producción pero la UI es trivial → Nivel 4 es tu techo.

Cada nivel tiene un costo. Cada nivel resuelve problemas reales.

La madurez no es usar el nivel más alto.  
Es **usar el nivel adecuado para el momento actual**.

### El manifiesto AETHERYON

> **Construimos para hoy, pero no hipotecamos mañana.**
>
> Separamos responsabilidades no por moda, sino porque el desorden tiene interés compuesto.
>
> Probamos no por cumplir métricas, sino porque lo que no se prueba, se rompe cuando más duele.
>
> Documentamos no por cumplir, sino porque el código dice *cómo*, pero el *por qué* se pierde si no se escribe.
>
> Y escalamos solo cuando el dolor de no hacerlo supera el costo de hacerlo.

### La arquitectura como supervivencia

Un sistema que sigue AETHERYON no es un sistema con una arquitectura.

Es un sistema con **una identidad evolutiva**.

Sabe de dónde viene. Sabe hacia dónde va. Y sabe que mañana, cuando las reglas del negocio cambien, cuando el equipo crezca, cuando el usuario pida más, podrá adaptarse **sin reescribirse**.

Porque la mejor arquitectura no es la que soporta el cambio.

Es la que **fue diseñada para esperarlo**.

---

**Código que funciona es común.  
Código que perdura es intencional.**
